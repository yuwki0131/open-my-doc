# scala-slickについて
* Futureで色々やるので大変。

## tupleのネストでtuple22問題を回避

### 問題点
* DBのテーブルのカラム数が22を超えると、Slickのテーブルの表現がcase classからHListに変わる。これは辛い。
* これはScalaのtupleの要素数の上限がそもそも22個までであり、case classの要素数もそれに伴って22個が上限。
  * 常識的に考えて要素数22個超えのtupleもcase classも普通使わないし、
    これだけ要素があるなら、普通はListなどを使うべき。
    * Wikipediaによれば、
      "多くの関数型言語は60前後の要素まで許容されている。"らしい。
      [タプル - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%BF%E3%83%97%E3%83%AB)
* しかし、カラム数22超えのテーブルなんて普通。
* Slick-codegenに頼らないなら以下の方法もある。
  * [Scala Compiler 2.10.4 fails to compile HList model using Slick 2.0, but sometimes it works. Why? · Issue #214 · playframework/play-slick](https://github.com/playframework/play-slick/issues/214)
  * しかし、codegenは使いたいし、shapedとかも良くわからない。
* この時、以下のようなコードを書くと思う。

### 解決策1: 取得したいカラム数が22未満の場合
* とっておきの解決策は、resultをかける手前で取得したいカラムを指定してしまうこと。
* 取得したいカラム数が22未満の場合は以下の方法が使える。。。

* この書き方により、sql直書きやインデックス指定による定義ではなくSlick(とcodegen)が提供している各要素でコードが書ける。

### 解決策2: 取得したいカラム数が22を超えてしまった場合
* resultの前でタプルのタプルを定義してしまう。また、resultの定義後は、要素をインデックスによる代入でなく、
  tupleをunapplyしてcase classに直接マッピングしてしまう。
* 現状、Rep型(Slick内部でのカラムの表現型)では、case classなどによる型の定義できない(or 出来るかもしれないが難しい)。

### メリットとデメリット
* メリット
  * sql直書きと比較して。sqlを実行しなくてもバグを発見出来る。
    * コンパイル時にある程度ミスを発見することが出来る。(ただし、エラーの出方が少しだけ特殊なので最初は戸惑うかもしれない)
  * インデックス指定によるカラム指定と比較してテーブル定義の変更に強い。
    * 大事なことなので、二度言うと**テーブル定義の変更にものすごく強い**。
    * ここ2, 3ヶ月で、テーブル定義はめまぐるしく変更しているが、テーブル変更による大きなトラブルは0!
      * カラム名修正、カラムの型変更、カラム削除、カラム追加、カラムの順序の変更(特に開発途中だとやりたくなるやつ)、
        全てに対応！(間違っている場合、エラーが出ます)
    * テーブル定義に失敗かのような巨大なテーブルにも対応。
    * 特に頻繁にテーブル定義が変更される絶賛開発中のプロジェクトではお薦め。
    * 名前によるカラム指定なので、インデックスずれによるトラブルも存在しない(当然といえば当然ではある)。
      * 後から、11番目と12番目のカラムの間にもうひとつカラムを追加したいといった時も、問題ない。
      * ちなみに、インデックスでカラム指定しているテーブル定義の変更時には、影響調査が必須。
      * この書き方(を徹底している)なら、理屈上は影響調査なしでcodegenでコードを再生成すればエラーが出て全ての修正箇所が分かるはず。
  * 解決策2で定義したネストしたcase classは当然プログラムの至る所で使いまわせる。
    * 一見、case class定義が煩雑に見えるが、結局はどこかで定義しないといけないcase classを定義している事が多い。
  * やっている事が明白で分かりやすい。(前述のISSUEのコードと比べて)
* デメリット
  * 指定するカラム数が多い場合はcase class定義が冗長になる。
    * 他で使えるとは言え、本来書かなくても良い処理を書いている事には違いない。
  * ミスが無くなるわけではない。(case class定義でミスすれば、結局バグにはなる)
  * 特殊な書き方なので所見の人には説明(or 理解する時間)が必要。
  * 特殊な書き方。。。
  * 今の所(2018/02/15現在)、本番稼働の実績0。

### 所感
* メリットの箇所が大分胡散臭い書き方になってしまったが、結果論から言うと、結構上手くいっている(今の所は)。
* sql直書きの場合、インデックス指定の場合と比較した場合の、実行速度などについては調べていない。(Future works)
* というか本来ORMapper(SlickはFRMだけど)はこういう所の役割をちゃんと担うべきなのでは。。。
* 今後のScala(version3, Dotty?)とそれに対応したSlickに期待したい。

## monadic joinの黄昏
*
